import { jsPDF } from "jspdf";

const prefix = {
  xmlns: "http://www.w3.org/2000/xmlns/",
  xlink: "http://www.w3.org/1999/xlink",
  svg: "http://www.w3.org/2000/svg",
};

export function download(svgInfo, filename) {
  window.URL = window.URL || window.webkitURL;
  const blob = new Blob(svgInfo.source, { type: "text/xml" });
  const url = window.URL.createObjectURL(blob);
  var body = document.body;
  var a = document.createElement("a");

  body.appendChild(a);
  a.setAttribute("download", filename + ".svg");
  a.setAttribute("href", url);
  a.style.display = "none";
  a.click();
  a.parentNode.removeChild(a);

  setTimeout(function () {
    window.URL.revokeObjectURL(url);
  }, 10);
}

function setInlineStyles(svg) {
  const emptySvg = window.document.createElementNS(prefix.svg, "svg");
  window.document.body.appendChild(emptySvg);
  const emptySvgDeclarationComputed = window.getComputedStyle(emptySvg);

  function explicitlySetStyle(element) {
    var cSSStyleDeclarationComputed = getComputedStyle(element);
    var i, len, key, value;
    var computedStyleStr = "";
    for (i = 0, len = cSSStyleDeclarationComputed.length; i < len; i++) {
      key = cSSStyleDeclarationComputed[i];
      value = cSSStyleDeclarationComputed.getPropertyValue(key);
      if (value !== emptySvgDeclarationComputed.getPropertyValue(key)) {
        computedStyleStr += key + ":" + value + ";";
      }
    }
    element.setAttribute("style", computedStyleStr);
  }
  function traverse(obj) {
    var tree = [];
    tree.push(obj);
    visit(obj);
    function visit(node) {
      if (node && node.hasChildNodes()) {
        var child = node.firstChild;
        while (child) {
          if (child.nodeType === 1 && child.nodeName !== "SCRIPT") {
            tree.push(child);
            visit(child);
          }
          child = child.nextSibling;
        }
      }
    }
    return tree;
  }
  // hardcode computed css styles inside svg
  const allElements = traverse(svg);
  let i = allElements.length;
  while (i--) {
    explicitlySetStyle(allElements[i]);
  }
}

function preprocess(svg, config) {
  svg.setAttribute("version", "1.1");
  svg.removeAttribute("xmlns");
  svg.removeAttribute("xlink");

  if (!svg.hasAttributeNS(prefix.xmlns, "xmlns")) {
    svg.setAttributeNS(prefix.xmlns, "xmlns", prefix.svg);
  }

  if (!svg.hasAttributeNS(prefix.xmlns, "xmlns:xlink")) {
    svg.setAttributeNS(prefix.xmlns, "xmlns:xlink", prefix.xlink);
  }

  setInlineStyles(svg);
  const rect = svg.getBoundingClientRect();
  svg.style.width = rect.width;
  svg.style.height = rect.height;
  console.log("svg", svg);
  let xmls = new XMLSerializer();
  const source = xmls.serializeToString(svg);
  const doctype =
    '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

  const svgInfo = {
    class: svg.getAttribute("class"),
    id: svg.getAttribute("id"),
    source: [doctype + source],
  };

  return svgInfo;
}

function getDefaultFileName(svgInfo) {
  var defaultFileName = "untitled";
  if (svgInfo.id) {
    defaultFileName = svgInfo.id;
  } else if (svgInfo.class) {
    defaultFileName = svgInfo.class;
  } else if (window.document.title) {
    defaultFileName = window.document.title
      .replace(/[^a-z0-9]/gi, "-")
      .toLowerCase();
  }

  return defaultFileName;
}

export function save(svgElement, config) {
  if (svgElement.nodeName !== "svg" || svgElement.nodeType !== 1) {
    throw Error("Input a valid svg element");
  }
  config = config || {};
  const svgInfo = preprocess(svgElement, config);
  const defaultFileName = getDefaultFileName(svgInfo);
  const filename = config.filename || defaultFileName;
  if (config.pdf) {
    exportToPDF({ ref: svgElement });
  }
  if (config.png) {
    return downloadPng({ ref: svgElement });
  }
  download(svgInfo, filename);
}

export function printDiv(ref, filename) {
  console.log(ref.style);
  let mywindow = window.open(
    "",
    "PRINT",
    "height=650,width=900,top=100,left=150"
  );
  mywindow.document.write(`<html><head><title>${filename}</title>`);
  mywindow.document.write("</head><body >");
  mywindow.document.write(`${ref.outerHTML}`);
  mywindow.document.write("</body></html>");

  mywindow.print();

  return true;
}

const exportToPDF = ({
  svgElement,
  fileName = "D3-Chart",
  label = "Generated By Lab Technology (c)",
}) => {
  svgElement.style.background = "white";
  const svg = new XMLSerializer().serializeToString(svgElement);
  const width = svgElement.width.baseVal.value + 50;
  const height = svgElement.height.baseVal.value + 50;

  let canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  let ctx = canvas.getContext("2d");

  const docPaddingTop = 20;
  const format = [width, height + docPaddingTop];
  let docPdf = new jsPDF({
    orientation: "landscape",
    unit: "px",
    format,
    compress: true,
    autoSize: false,
    printHeaders: true,
  });

  const date = new Date(Date.now());
  const documentDate = date.toLocaleDateString("en-US");

  let img = document.createElement("img");
  img.onload = () => {
    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);

    docPdf.setFontSize(11);
    docPdf.text(5, 10, documentDate);
    docPdf.text(fileName, (width - 50) / 2, 10, { align: "center" });
    docPdf.addImage(
      canvas.toDataURL("image/png"),
      "PNG",
      10,
      20,
      width,
      height,
      "slow"
    );
    docPdf.setFontSize(9);
    docPdf.text(label, (width - 50) / 2, height + 10, { align: "center" });
    docPdf.save(`${fileName}.pdf`);
  };
  img.setAttribute("src", "data:image/svg+xml;base64," + btoa(svg));
};

function triggerDownload(imgURI, fileName) {
  var evt = new MouseEvent("click", {
    view: window,
    bubbles: false,
    cancelable: true,
  });
  var a = document.createElement("a");
  a.setAttribute("download", fileName);
  a.setAttribute("href", imgURI);
  a.setAttribute("target", "_blank");
  a.dispatchEvent(evt);
}

function downloadPng({ ref, fileName = "D3-Chart" }) {
  const DOMURL = window.URL || window.webkitURL || window;
  ref.style.background = "white";
  let svg = new XMLSerializer().serializeToString(ref);
  let canvas = document.createElement("canvas");
  let svgSize = ref;
  console.log(svgSize.width);
  // let svgSize = $(svg)[0].getBoundingClientRect();
  canvas.width = svgSize.width.baseVal.value + 20;
  canvas.height = svgSize.height.baseVal.value + 20;

  let ctx = canvas.getContext("2d");
  var img = new Image();
  var svgBlob = new Blob([svg], { type: "image/svg+xml;charset=utf-8" });
  var url = DOMURL.createObjectURL(svgBlob);
  img.onload = function () {
    ctx.drawImage(img, 0, 0);
    DOMURL.revokeObjectURL(url);
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
      var blob = canvas.msToBlob();
      navigator.msSaveOrOpenBlob(blob, fileName);
    } else {
      var imgURI = canvas
        .toDataURL("image/png")
        .replace("image/png", "image/octet-stream");
      triggerDownload(imgURI, fileName + ".png");
    }
    //document.removeChild(canvas);
  };
  img.src = url;
}
